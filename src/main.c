/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "common.h"
#include <stdio.h>
#include "clock.h"   /* Include il nostro modulo di gestione clock */
#include "log.h"     /* Include il sistema di logging */
#include "itm.h"     /* Include il supporto ITM per console via SWO */
#include "uart.h"    /* Include il supporto UART per console seriale */
#include "gpio.h"    /* Include la configurazione GPIO CNC */
#include "systick.h" /* Include il timer di sistema SysTick */
#include "test.h"    /* Include le funzioni di test hardware */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif



int main(void)
{
    int clock_status;
    int log_status;

    /* =========================================================================
     * INIZIALIZZAZIONE DEL SISTEMA DI CLOCK
     * =========================================================================
     *
     * IMPORTANTE: La prima cosa da fare all'avvio è configurare il clock!
     * Tutte le periferiche e i timing dipendono dalla configurazione del clock.
     *
     * Al reset, l'STM32F103 parte con HSI a 8 MHz. Noi lo portiamo a 72 MHz
     * usando HSE + PLL.
     */

    /* Configura il sistema di clock a 72 MHz */
    clock_status = SystemClock_Config();

    /* =========================================================================
     * WORKAROUND PER SWV/ITM
     * =========================================================================
     *
     * Dopo aver configurato il clock a 72 MHz, è necessario un breve delay
     * per permettere al debugger ST-Link di sincronizzarsi con la nuova
     * frequenza prima di inizializzare l'ITM.
     *
     * Senza questo delay, potresti vedere l'errore "failed to init SWV"
     * nel debugger STM32CubeIDE.
     *
     * Questo delay è necessario solo per il debug, in produzione può essere
     * rimosso se non usi ITM.
     */
    for (volatile u32 i = 0; i < 100000; i++) {
        __NOP();  /* Delay ~10ms @ 72 MHz */
    }

    /* Verifica che la configurazione sia andata a buon fine */
    if (clock_status != CLOCK_OK)
    {
        /* Errore nella configurazione del clock!
         * Questo può accadere se:
         * - L'oscillatore esterno HSE non è presente o non funziona
         * - Il PLL non riesce a fare lock
         *
         * In un'applicazione reale, qui dovresti:
         * 1. Accendere un LED di errore
         * 2. Inviare un messaggio di debug via UART
         * 3. Tentare una configurazione fallback (es. rimanere su HSI a 8 MHz)
         * 4. Eventualmente resettare il sistema
         */

        /* Per ora, stampa un messaggio di errore e resta bloccato */
        if (clock_status == CLOCK_ERROR_HSE)
        {
            strcpy(log_site(),"ERROR: HSE non si avvia! Verifica il quarzo esterno");
        }
        else if (clock_status == CLOCK_ERROR_PLL)
        {
        	strcpy(log_site(),"ERRORE: PLL non fa lock! Problema di configurazione");
        }

        /* Loop infinito in caso di errore */
        while(1);
    }

    /* =========================================================================
     * INIZIALIZZAZIONE DEL SISTEMA DI LOGGING
     * =========================================================================
     *
     * Inizializza il buffer circolare in RAM dedicata (2KB @ 0x20004800).
     * Il logging è thread-safe e interrupt-safe.
     */

    log_status = log_init();
    if (log_status != LOG_OK)
    {
        log_error("Inizializzazione sistema log fallita!");
        while(1);
    }

    /* Primo log: sistema avviato! */
    log_info("Sistema STM32F103 avviato con successo");

    /* Log della configurazione completata */
    log_info("Clock configurato a 72 MHz");
    log_debug("HSE: 8 MHz, PLL: x9, SYSCLK: 72 MHz");

    /* =========================================================================
     * INIZIALIZZAZIONE ITM (CONSOLE VIA SWO)
     * =========================================================================
     *
     * L'ITM (Instrumentation Trace Macrocell) permette di inviare messaggi
     * di debug attraverso il pin SWO dello ST-Link, senza usare pin UART.
     *
     * IMPORTANTE: Funziona solo se il debugger è connesso!
     * Se il debugger non è connesso, itm_init() e itm_write() ritornano
     * con timeout ma NON bloccano il programma.
     */
#if ENABLE_ITM

    int itm_status = itm_init();
    if (itm_status == ITM_OK)
    {
        /* ITM inizializzato con successo */
        itm_write("\n");
        itm_write("=======================================================\n");
        itm_write("  STM32F103C8T6 - Console via ITM/SWO\n");
        itm_write("=======================================================\n");
        itm_write("SYSCLK: 72 MHz | SWO: 2 MHz | ITM Port: 0\n");
        itm_write("=======================================================\n\n");

        /* Dumpa i log accumulati fino ad ora */
        itm_write("[BOOT] Dump dei log di avvio:\n\n");
        log_via_itm();  /* Questa funzione svuota il buffer circolare! */

        itm_write("\n[BOOT] Sistema pronto.\n");
        itm_write("[BOOT] Entrando nel main loop...\n\n");

        /* Riaggiungi un log per il main loop (il buffer è stato svuotato) */
        log_info("Main loop avviato");
    }
    else
    {
        /* ITM non disponibile (debugger non connesso o errore) */
        /* Non è un errore critico, continuiamo comunque */
        log_warning("ITM non disponibile (debugger non connesso?)");
    }

    #endif

    /* =========================================================================
     * INIZIALIZZAZIONE GPIO (SISTEMA CNC)
     * =========================================================================
     *
     * Configura tutti i GPIO per il controller CNC 3 assi:
     * - Motori stepper (STEP, DIR, ENABLE)
     * - Encoder rotativi (canali A/B)
     * - Finecorsa (MIN/MAX)
     * - I/O generici
     * - LED di stato
     *
     * IMPORTANTE: Questa funzione deve essere chiamata PRIMA di uart_init()
     * perché abilita i clock GPIO necessari.
     */

    int gpio_status = gpio_init_all();
    if (gpio_status != GPIO_OK)
    {
        log_error("Inizializzazione GPIO fallita!");
        while(1);
    }

    log_info("GPIO CNC inizializzati correttamente");

    /* =========================================================================
     * INIZIALIZZAZIONE SYSTICK (TIMER DI SISTEMA)
     * =========================================================================
     *
     * Configura il SysTick timer per generare interrupt ogni 1ms.
     * Fornisce tick counter e funzioni di delay precise per scheduling.
     *
     * IMPORTANTE: Deve essere inizializzato DOPO SystemClock_Config() perché
     * usa la frequenza SYSCLK per calcolare il reload value.
     */

    int systick_status = systick_init(SystemClock_GetFreq());
    if (systick_status != SYSTICK_OK)
    {
        log_error("Inizializzazione SysTick fallita!");
        while(1);
    }

    log_info("SysTick inizializzato: tick a 1ms");

    /* =========================================================================
     * INIZIALIZZAZIONE UART (CONSOLE SERIALE)
     * =========================================================================
     *
     * L'UART permette di inviare messaggi di debug attraverso un cavo seriale,
     * senza bisogno del debugger. Funziona sempre, anche in produzione.
     *
     * COLLEGAMENTO:
     * - TX (PB10) → RX dell'adattatore USB-UART
     * - GND       → GND dell'adattatore
     * - Baud: 115200, 8N1
     *
     * Visualizza con: minicom, putty, screen, etc.
     *
     * NOTA: I pin UART3 (PB10/PB11) sono configurati internamente da uart_init()
     */

    int uart_status = uart_init();
    if (uart_status == UART_OK)
    {
        /* UART inizializzato con successo */
        uart_write("\r\n\r\n");
        uart_write("=======================================================\r\n");
        uart_write("  STM32F103C8T6 - Console UART @ 115200 baud\r\n");
        uart_write("=======================================================\r\n");
        uart_write("SYSCLK: 72 MHz | UART: PA9(TX) PA10(RX)\r\n");
        uart_write("=======================================================\r\n\r\n");

        /* Dumpa i log accumulati fino ad ora */
        uart_write("[BOOT] Dump dei log di avvio:\r\n\r\n");
        log_via_uart();  /* Questa funzione svuota il buffer circolare! */

        uart_write("\r\n[BOOT] Sistema pronto.\r\n");
        uart_write("[BOOT] Entrando nel main loop...\r\n\r\n");

        /* Riaggiungi un log per il main loop (il buffer è stato svuotato) */
        log_info("Main loop avviato");
    }
    else
    {
        /* UART non disponibile - errore di inizializzazione */
        log_error("UART init failed!");
    }

    /* =========================================================================
     * MAIN LOOP
     * =========================================================================
     */

    /* Loop principale dell'applicazione */
    /* Pattern lampeggio LED: 200ms OFF, 400ms ON, 400ms OFF, 200ms ON (ciclo 1200ms) */

    log_info("Entrando nel main loop con pattern LED");

    /* Variabile di stato per finecorsa (usata anche per macchina a stati futura) */
    int limit_active = 0;

    while(1)
    {
        /* =====================================================================
         * TEST HARDWARE
         * =====================================================================
         * Esegue i test hardware abilitati (controllati da macro in test.h).
         * Se un test rileva un problema (es. finecorsa attivo), il LED si ferma.
         */

        EVAL_TEST_LIMIT(limit_active = test_limit();)

        /* =====================================================================
         * PATTERN LED STATO
         * =====================================================================
         * Il LED lampeggia con pattern riconoscibile solo se nessun test
         * sta bloccando il sistema (es. nessun finecorsa premuto).
         */

        if (!limit_active)
        {
            /* Pattern normale: 200ms OFF, 400ms ON, 400ms OFF, 200ms ON */

            /* Fase 1: LED OFF per 200ms */
            gpio_set(LED_STATUS_PORT, LED_STATUS_PIN);     // LED spento (attivo LOW)
            systick_delay_ms(200);

            /* Fase 2: LED ON per 400ms */
            gpio_reset(LED_STATUS_PORT, LED_STATUS_PIN);   // LED acceso
            systick_delay_ms(400);

            /* Fase 3: LED OFF per 400ms */
            gpio_set(LED_STATUS_PORT, LED_STATUS_PIN);     // LED spento
            systick_delay_ms(400);

            /* Fase 4: LED ON per 200ms */
            gpio_reset(LED_STATUS_PORT, LED_STATUS_PIN);   // LED acceso
            systick_delay_ms(200);
        }
        else
        {
            /* Finecorsa attivo: LED resta acceso fisso */
            gpio_reset(LED_STATUS_PORT, LED_STATUS_PIN);   // LED acceso fisso
            systick_delay_ms(100);  // Piccolo delay per ridurre frequenza polling
        }

        /* I delay usano SysTick invece di busy-wait, permettendo alla CPU
         * di andare in sleep (WFI) durante l'attesa, riducendo il consumo */
    }

    /* Nota: questo punto non viene mai raggiunto perché il while(1) è infinito */
    return 0;
}
